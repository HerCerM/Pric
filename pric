#!/usr/bin/env groovy

/* Copyright 2020 Hernán José Cervera Manzanilla
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@Grab(group='org.asciidoctor', module='asciidoctorj', version='2.3.0')
@Grab(group='org.asciidoctor', module='asciidoctorj-pdf', version='1.5.3')

import groovy.cli.commons.CliBuilder

import org.asciidoctor.*
import org.asciidoctor.extension.*

import static org.asciidoctor.Asciidoctor.Factory.create
import static org.asciidoctor.AttributesBuilder.attributes
import static org.asciidoctor.OptionsBuilder.options

Map<String, String> ext2type = [
        // Backend
        java: 'java',
        groovy: 'groovy',
        php: 'php',
        py: 'python',
        // Frontend
        js: 'javascript',
        html: 'html',
        css: 'css',
        // Scripting
        bat: 'batch',
        sh: 'bash',
        // Typesetting
        tex: 'latex',
        md: 'markdown',
        adoc: 'asciidoc',
        // Low level
        c: 'c'
]

class PricPDFPrinter {
    // CLI options
    List<String> extensions
    String outputFilename
    String title
    List<String> paths
    boolean recursive
    boolean keepAsciidoc

    // Helper data
    Map<String, String> ext2type

    void print() {
        // Check the file passed by -o has .pdf extension
        if (!outputFilename.endsWith('.pdf')) {
            Logger.error('File name supplied by -o is not a PDF file. ' +
                    'Verify the filename has extension \'.pdf\'.')
            System.exit(1)
        }
        // If it has .pdf extension, generate the PDF file
        File adocFile = buildAdocFile()
        generatePDF(adocFile)

        // Conditional cleanup
        if (!keepAsciidoc) {
            adocFile.delete()
        }
    }

    private void generatePDF(File adocFile) {
        Asciidoctor asciidoctor = create()

        // Add support for include directive
        asciidoctor.javaExtensionRegistry()
                .includeProcessor(CharBasedIncludeProcessor)

        Attributes attributes = attributes().sourceHighlighter('coderay').get()
        Options options = options().inPlace(true).backend('pdf').attributes(attributes).get()

        asciidoctor.convertFile(adocFile, options)
    }

    private File buildAdocFile() {
        // Filename without extension
        String filenameNoExt = outputFilename.split('[.]')[0]

        // Create AsciiDoc file
        File adocFile = new File("${filenameNoExt}.adoc")
        // Set file title
        adocFile.write("= ${title ?: filenameNoExt}\n\n")

        includeFilesInAdoc(recursive, paths ?: ['.'], adocFile)
        return adocFile
    }

    private void includeFilesInAdoc(boolean recursive, List<String> paths, File adocFile) {
        int matchedFiles = 0 // Keep track of how many files match the extensions supplied

        for (String path : paths) {

            File dir = new File(path)
            // Skip non-existent path
            if (!dir.exists()) {
                Logger.warn("Non existent supplied path... skipping $dir.absolutePath")
                continue
            }
            // Skip if is not directory
            if (!dir.isDirectory()) {
                Logger.warn("Supplied path is not a directory... skipping $dir.absolutePath")
                continue
            }

            // Iterate files and build adoc file
            dir.eachFile { file ->
                if (file.isDirectory() && recursive) {
                    includeFilesInAdoc(recursive, [file.getPath()], adocFile)
                }
                if (!file.isDirectory()) {
                    def partedFilename = file.name.split('[.]')
                    String fileExtension =
                            partedFilename.size() > 1 ? partedFilename[1] : ''
                    if (fileExtension in extensions) {
                        matchedFiles++
                        adocFile.withWriterAppend('utf-8') { writer ->
                            writer.writeLine("""\
                            === $file.name
                            [source,${ext2type[fileExtension]}]
                            ----
                            include::$file.absolutePath[]
                            ----
                            """.stripIndent())
                        }
                    }
                }
            }
        }

        if (matchedFiles == 0) {
            Logger.info('No files were found. Check the values of -e and -p (if supplied).')
            adocFile.delete()
            System.exit(2)
        }
    }
}

// Define API
CliBuilder cli = new CliBuilder(usage: 'Print multiple char-based files to a a single PDF')
cli.with {
    h(longOpt: 'help', 'usage information')
    e(longOpt: 'extensions', args: '+', valueSeparator: ',', '[required] extensions of the files to be printed')
    o(longOpt: 'output', type: String, '[required] output filename of the PDF')
    t(longOpt: 'title', type: String, 'title of the document. If omitted, filename -o is used')
    p(longOpt: 'paths', args: '+', valueSeparator: ',', 'directories to search for the files')
    r(longOpt: 'recursive', 'recurse sub-directories')
    k(longOpt: 'keep-asciidoc', 'preserve Asciidoc file after PDF generation')
}
def requiredOptions = ['e', 'o']

// Parse command line arguments
def options = cli.parse(args)

// Print help message
if (options.h) {
    cli.usage()
    System.exit(0)
}

// Required options check
for (def option : requiredOptions) {
    if (!options[option]) {
        Logger.error('Missing one or more required options.')
        cli.usage()
        System.exit(0)
    }
}

// Build printer
PricPDFPrinter printer = new PricPDFPrinter(
        extensions: options.es, outputFilename: options.o, title: options.t ?: '',
        paths: options.ps ?: [], recursive: options.r, keepAsciidoc: options.k,
        ext2type: ext2type
)

printer.print()

// Helper logger class
class Logger {
    static boolean enabled = true
    final static String INFO = 'INFO'
    final static String WARNING = 'WARNING'
    final static String ERROR = 'ERROR'

    private static String noticeTemplate(String notice) { "[ $notice ]" }

    private static void log(String notice, String msg, PrintStream stream) {
        if (enabled) stream.println("${noticeTemplate(notice)} $msg")
    }

    static void info(String msg) {
        log(INFO, msg, System.out)
    }
    static void warn(String msg) {
        log(WARNING, msg, System.err)
    }
    static void error(String msg) {
        log(ERROR, msg, System.err)
    }
}

// Helper class required to support the include directive
class CharBasedIncludeProcessor extends IncludeProcessor {

    CharBasedIncludeProcessor(Map<String, Object> config) {
        super(config)
    }

    @Override
    // Handling of accepted file types is done in PricPDFPrinter, thus everything
    // is considered acceptable at this point.
    boolean handles(String target) { return true }

    @Override
    void process(org.asciidoctor.ast.Document document, PreprocessorReader reader,
                 String target, Map<String, Object> attributes) {

        StringBuilder content = readContent(target)
        reader.push_include(content.toString(), target, target, 1, attributes)
    }

    private StringBuilder readContent(String target) {
        StringBuilder content = new StringBuilder()
        new File(target).eachLine {line ->
            content.append(line).append('\n')
        }
        return content
    }
}