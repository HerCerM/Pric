#!/usr/bin/env groovy
/* Copyright 2020 Hernán José Cervera Manzanilla
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@Grab(group='org.asciidoctor', module='asciidoctorj', version='2.3.0')
@Grab(group='org.asciidoctor', module='asciidoctorj-pdf', version='1.5.3')
@Grab(group='info.picocli', module='picocli', version='4.4.0')

import picocli.CommandLine
import picocli.CommandLine.Command
import picocli.CommandLine.Option
import picocli.CommandLine.Parameters
import picocli.CommandLine.ArgGroup

import java.util.concurrent.Callable
import java.util.regex.Pattern

import org.asciidoctor.*
import org.asciidoctor.extension.*

import static org.asciidoctor.Asciidoctor.Factory.create
import static org.asciidoctor.AttributesBuilder.attributes
import static org.asciidoctor.OptionsBuilder.options

@Command(name = 'pric',
        version = 'pric 0.6.0',
        mixinStandardHelpOptions = true,
        headerHeading = '%n',
        header = 'Print multiple source code files to a single PDF file.',
        customSynopsis = [
                'pric @|yellow <file>|@ (@|yellow -e|@ <ext>[,<ext>...] | @|yellow -f|@ <regex>[:<regex>...]) [OPTIONS]'
        ],
        synopsisHeading = '%n',
        parameterListHeading = '%nParameters:%n',
        optionListHeading = '%nOptions:%n',
        exitCodeListHeading = '%nExit codes:%n',
        exitCodeList = [
                '0: Successful PDF generation.',
                '1: No PDF was generated.'
        ],
        footerHeading = '%nExamples:%n',
        footer = 'Print to out.pdf all Java and XML files on the current dir and its sub-dirs.%n' +
            '@|yellow pric out.pdf -re java,xml|@' +
            '%n%nPrint to out.pdf all Markdown files and the LICENSE file found on the current directory.%n' +
            '@|yellow pric out.pdf -f \'LICENSE:.*[.]md\'|@')
class Pric implements Callable<Void> {
    @ArgGroup(exclusive = true, multiplicity = '1')
    FilesFilter filesFilter
    @Parameters(index = '0', paramLabel = 'file',
            description = "Filename of the PDF, must end in '.pdf'.")
    String outputFilename
    @Option(names = ['-t', '--title'],
            description = 'Title of the document. If omitted, filename is used.')
    String title
    @Option(names = ['-a', '--author'],
            description = 'Author of the document.')
    String author
    @Option(names = ['-p', '--paths'], paramLabel = '<path>', split = '[?]', splitSynopsisLabel = '?',
            description = 'Absolute or relative paths to directories to search for files ' +
                    '(default is current directory)')
    List<String> paths = ['.']
    @Option(names = ['-r', '--recursive'],
            description = 'Recurse sub-directories.')
    boolean recursive
    @Option(names = ['-k', '--keep-asciidoc'],
            description = 'Preserve AsciiDoc file after PDF generation.')
    boolean keepAsciidoc
    @Option(names = ['-s', '--silent'],
            description = 'Do not show log messages.')
    boolean loggerSilent
    @Option(names = ['-c', '--compact'], description = 'Produce a PDF with less pages.')
    boolean compact

    static class FilesFilter {
        @Option(names = ['-e', '--extensions'], split = ',', paramLabel = '<ext>',
                description = 'Extensions of the files to be printed.')
        List<String> extensions
        @Option(names = ['-f', '--files'], split = ':', paramLabel = '<regex>',
                description = 'Match filenames by regex.')
        List<Pattern> patterns
    }

    def ext2type = [
            // Backend
            java: 'java',
            groovy: 'groovy',
            php: 'php',
            py: 'python',
            // Frontend
            js: 'javascript',
            html: 'html',
            css: 'css',
            // Scripting
            bat: 'batch',
            sh: 'bash',
            // Typesetting
            tex: 'latex',
            md: 'markdown',
            // Low level
            c: 'c'
    ]

    private Closure<Boolean> matchStrategy() {
        def strategy = { false }

        if (filesFilter.extensions) {
            strategy = { filename, fileExtension -> fileExtension in filesFilter.extensions }
        }
        if (filesFilter.patterns) {
            strategy = {
                filename, fileExtension -> {
                    boolean matches = false
                    for (def pattern : filesFilter.patterns) {
                        if ((filename =~ pattern).matches()) {
                            matches = true
                            break
                        }
                    }
                    return matches
                }
            }
        }

        return strategy
    }

    @Override
    Void call() throws Exception {
        // Configure PDF printer
        PricPDFPrinter printer = new PricPDFPrinter(
                pric: this,
                logger: new Logger(silent: loggerSilent),
                matchStrategy: matchStrategy())
        printer.print() // Generate files
        return new Void()
    }

    static void main (String... args) {
        new CommandLine(new Pric()).execute(args)
        System.exit(0)
    }
}

class PricPDFPrinter {
    // Options and parameters bindings
    Pric pric
    // Logger
    Logger logger
    // Filename match strategy
    Closure<Boolean> matchStrategy

    void print() {
        // Check the file passed by -o has .pdf extension
        if (!pric.outputFilename.endsWith('.pdf')) {
            logger.error('File name supplied by -o is not a PDF file. ' +
                    'Verify the filename has extension \'.pdf\'.')
            System.exit(1)
        }
        // If it has .pdf extension, generate the PDF file
        File adocFile = buildAdocFile()
        generatePDF(adocFile)

        // Conditional cleanup
        if (!pric.keepAsciidoc) {
            adocFile.delete()
        }
    }

    private void generatePDF(File adocFile) {
        Asciidoctor asciidoctor = create()

        // Add support for include directive
        asciidoctor.javaExtensionRegistry()
                .includeProcessor(CharBasedIncludeProcessor)

        Attributes attributes = attributes().sourceHighlighter('coderay').get()
        Options options = options().inPlace(true).backend('pdf').attributes(attributes).get()

        logger.info('Generating PDF, please wait...')

        asciidoctor.convertFile(adocFile, options)

        logger.info('Successful PDF generation.')
    }

    private File buildAdocFile() {
        // Filename without extension
        String filenameNoExt = pric.outputFilename.split('[.]')[0]

        // Create AsciiDoc file
        File adocFile = new File("${filenameNoExt}.adoc")

        // Set file title, author and doctype
        StringBuilder header = new StringBuilder("= ${pric.title ?: filenameNoExt}\n")
        if (pric.author) { header.append(":author: $pric.author").append('\n') }
        header.append(':source-highlighter: coderay').append('\n')
        if (!pric.compact) { header.append(':doctype: book').append('\n') }
        else if (pric.author) { header.append('\n[.text-center]\n{author}\n') }

        adocFile.withWriter('utf-8') { writer ->
            writer.write(header.toString())
        }

        // Add include directives
        includeFilesInAdoc(pric.recursive, pric.paths, adocFile)
        return adocFile
    }

    private void includeFilesInAdoc(boolean recursive, List<String> paths, File adocFile) {
        if (includeFilesInAdocHelper(recursive, paths, adocFile, 0) == 0) {
            logger.info('No files were found. Check the values of -e and -p (if supplied).')
            adocFile.delete()
            System.exit(1)
        }
    }

    private int includeFilesInAdocHelper(boolean recursive, List<String> paths, File adocFile, int matched) {
        for (String path : paths) {
            File dir = new File(path)
            // Skip non-existent path
            if (!dir.exists()) {
                logger.warn("Non existent path, skipping: $dir.absolutePath")
                continue
            }
            // Skip if is not directory
            if (!dir.isDirectory()) {
                logger.warn("Path is not a directory, skipping: $dir.absolutePath")
                continue
            }

            // Iterate files and build adoc file
            dir.eachFile { file ->
                if (file.isDirectory() && !file.name.startsWith('.') && recursive) {
                    matched = includeFilesInAdocHelper(recursive, [file.path], adocFile, matched)
                }
                if (!file.isDirectory()) {
                    def partedFilename = file.name.split('[.]')
                    String fileExtension = partedFilename.size() > 1 ? partedFilename[1] : ''
                    if (matchStrategy.call(file.name, fileExtension)) {
                        logger.info("Adding to output file: $file.absolutePath")

                        matched++
                        adocFile.withWriterAppend('utf-8') { writer ->
                            writer.writeLine("""
                            ${ pric.compact ? ".$file.name" : "== [small]#$file.name#"}
                            [%autofit]
                            [source,${pric.ext2type[fileExtension] ?: 'text'},subs="macros"]
                            ----
                            include::$file.absolutePath[]
                            ----""".stripIndent())
                        }
                    }
                }
            }
        }

        return matched
    }
}

// Helper logger class
class Logger {
    boolean silent = false
    final static String INFO = 'INFO'
    final static String WARNING = 'WARNING'
    final static String ERROR = 'ERROR'

    private static String noticeTemplate(String notice) { "[$notice]" }

    private void log(String notice, String msg, PrintStream stream) {
        if (!silent) stream.println("${noticeTemplate(notice)} $msg")
    }

    void info(String msg) {
        log(INFO, msg, System.out)
    }
    void warn(String msg) {
        log(WARNING, msg, System.err)
    }
    void error(String msg) {
        log(ERROR, msg, System.err)
    }
}

// Helper class used to substitute the regular output of the 'include' preprocessor directive.
// By default, the include directive adds the lines of the specified files into the current document.
// However, IF the file has certain extensions,
//     (check the extensions here: https://asciidoctor.org/docs/user-manual/#include-nonasciidoc)
// then Asciidoctor allows recursive includes to be applied. For the purpose of this script I do NOT
// want that. Moreover, if a file has a line matching '----', irrelevant to its extension, the output
// of the code listing is broken. To prevent this I pass through every line of each included file with
// the 'pass:' macro, as seen in the readContent method. Albeit not an elegant solution, it works.
class CharBasedIncludeProcessor extends IncludeProcessor {
    CharBasedIncludeProcessor(Map<String, Object> config) { super(config) }
    @Override boolean handles(String target) { return true }

    @Override
    void process(org.asciidoctor.ast.Document document, PreprocessorReader reader,
                 String target, Map<String, Object> attributes) {
        reader.push_include(readContent(target).toString(), target, target, 1, attributes)
    }

    private StringBuilder readContent(String target) {
        StringBuilder builder = new StringBuilder()
        new File(target).eachLine { line -> builder.append("pass:[$line]\n") }
        return builder
    }
}